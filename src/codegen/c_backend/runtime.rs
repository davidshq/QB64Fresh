//! Runtime library code generation for QB64Fresh C backend.
//!
//! This module generates the inline runtime library declarations that provide
//! the core functionality for QB64Fresh programs: string handling, I/O operations,
//! math functions, and built-in QB64 functions.
//!
//! When `RuntimeMode::Inline` is selected, these functions are embedded directly
//! in the generated C code, making the output self-contained and portable.
//!
//! When `RuntimeMode::External` is selected, the generated code instead includes
//! a header file reference to link against the external runtime library.

use std::fmt::Write;

use super::RuntimeMode;

/// Emits the header section including runtime declarations.
///
/// This function writes the standard includes and either inline runtime code
/// or external library references based on the configured runtime mode.
pub(super) fn emit_header(output: &mut String, runtime_mode: RuntimeMode) {
    writeln!(output, "/* Generated by QB64Fresh */").unwrap();
    writeln!(output, "#include <stdio.h>").unwrap();
    writeln!(output, "#include <stdlib.h>").unwrap();
    writeln!(output, "#include <stdint.h>").unwrap();
    writeln!(output, "#include <stdbool.h>").unwrap();
    writeln!(output, "#include <string.h>").unwrap();
    writeln!(output, "#include <math.h>").unwrap();
    writeln!(output, "#include <ctype.h>").unwrap();
    writeln!(output).unwrap();

    match runtime_mode {
        RuntimeMode::Inline => {
            // Inline runtime library declarations
            emit_runtime_declarations(output);
        }
        RuntimeMode::External => {
            // Use external runtime library
            writeln!(output, "#include \"qb64fresh_rt.h\"").unwrap();
            writeln!(output).unwrap();
            // Alias for compatibility with inline code style
            writeln!(output, "typedef QbString qb_string;").unwrap();
            writeln!(output).unwrap();
            writeln!(output, "/* Using external QB64Fresh runtime library */").unwrap();
            writeln!(
                output,
                "/* Compile with: gcc -I<include_path> program.c -L<lib_path> -lqb64fresh_rt */"
            )
            .unwrap();
            writeln!(output).unwrap();
        }
    }
}

/// Emits the complete inline runtime library declarations.
///
/// This includes:
/// - String type definition and operations (allocation, concatenation, comparison)
/// - PRINT functions for different types
/// - INPUT functions for user input
/// - Built-in string functions (LEN, CHR$, ASC, LEFT$, RIGHT$, MID$, etc.)
/// - Math helper functions (SGN, PI, RND, CLAMP)
fn emit_runtime_declarations(output: &mut String) {
    writeln!(output, "/* QB64Fresh Runtime Library */").unwrap();
    writeln!(output).unwrap();

    emit_string_type(output);
    emit_string_functions(output);
    emit_print_functions(output);
    emit_input_functions(output);
    emit_string_comparison(output);
    emit_builtin_functions(output);
    emit_math_functions(output);
    emit_string_manipulation(output);
    emit_utility_functions(output);
    emit_file_io_functions(output);
    emit_error_handling(output);
    emit_keyboard_functions(output);
}

/// Emits the qb_string type definition.
fn emit_string_type(output: &mut String) {
    writeln!(output, "typedef struct qb_string {{").unwrap();
    writeln!(output, "    char* data;").unwrap();
    writeln!(output, "    size_t len;").unwrap();
    writeln!(output, "    size_t capacity;").unwrap();
    writeln!(output, "}} qb_string;").unwrap();
    writeln!(output).unwrap();
}

/// Emits core string allocation and manipulation functions.
fn emit_string_functions(output: &mut String) {
    // String creation
    writeln!(output, "qb_string* qb_string_new(const char* s) {{").unwrap();
    writeln!(output, "    qb_string* str = malloc(sizeof(qb_string));").unwrap();
    writeln!(output, "    str->len = strlen(s);").unwrap();
    writeln!(output, "    str->capacity = str->len + 1;").unwrap();
    writeln!(output, "    str->data = malloc(str->capacity);").unwrap();
    writeln!(output, "    memcpy(str->data, s, str->len + 1);").unwrap();
    writeln!(output, "    return str;").unwrap();
    writeln!(output, "}}").unwrap();
    writeln!(output).unwrap();

    // String deallocation
    writeln!(output, "void qb_string_free(qb_string* s) {{").unwrap();
    writeln!(output, "    if (s) {{ free(s->data); free(s); }}").unwrap();
    writeln!(output, "}}").unwrap();
    writeln!(output).unwrap();

    // String concatenation
    writeln!(
        output,
        "qb_string* qb_string_concat(qb_string* a, qb_string* b) {{"
    )
    .unwrap();
    writeln!(output, "    qb_string* result = malloc(sizeof(qb_string));").unwrap();
    writeln!(output, "    result->len = a->len + b->len;").unwrap();
    writeln!(output, "    result->capacity = result->len + 1;").unwrap();
    writeln!(output, "    result->data = malloc(result->capacity);").unwrap();
    writeln!(output, "    memcpy(result->data, a->data, a->len);").unwrap();
    writeln!(
        output,
        "    memcpy(result->data + a->len, b->data, b->len + 1);"
    )
    .unwrap();
    writeln!(output, "    return result;").unwrap();
    writeln!(output, "}}").unwrap();
    writeln!(output).unwrap();
}

/// Emits PRINT functions for different data types.
fn emit_print_functions(output: &mut String) {
    writeln!(output, "void qb_print_int(int64_t n) {{").unwrap();
    writeln!(output, "    printf(\"%lld\", (long long)n);").unwrap();
    writeln!(output, "}}").unwrap();
    writeln!(output).unwrap();

    writeln!(output, "void qb_print_float(double n) {{").unwrap();
    writeln!(output, "    printf(\"%g\", n);").unwrap();
    writeln!(output, "}}").unwrap();
    writeln!(output).unwrap();

    writeln!(output, "void qb_print_string(qb_string* s) {{").unwrap();
    writeln!(output, "    printf(\"%s\", s->data);").unwrap();
    writeln!(output, "}}").unwrap();
    writeln!(output).unwrap();

    writeln!(output, "void qb_print_newline(void) {{").unwrap();
    writeln!(output, "    printf(\"\\n\");").unwrap();
    writeln!(output, "}}").unwrap();
    writeln!(output).unwrap();

    writeln!(output, "void qb_print_tab(void) {{").unwrap();
    writeln!(output, "    printf(\"\\t\");").unwrap();
    writeln!(output, "}}").unwrap();
    writeln!(output).unwrap();
}

/// Emits INPUT functions for reading user input.
fn emit_input_functions(output: &mut String) {
    writeln!(
        output,
        "void qb_input_string(const char* prompt, qb_string** var) {{"
    )
    .unwrap();
    writeln!(output, "    char buffer[1024];").unwrap();
    writeln!(output, "    if (prompt) printf(\"%s\", prompt);").unwrap();
    writeln!(output, "    if (fgets(buffer, sizeof(buffer), stdin)) {{").unwrap();
    writeln!(output, "        size_t len = strlen(buffer);").unwrap();
    writeln!(
        output,
        "        if (len > 0 && buffer[len-1] == '\\n') buffer[len-1] = '\\0';"
    )
    .unwrap();
    writeln!(output, "        if (*var) qb_string_free(*var);").unwrap();
    writeln!(output, "        *var = qb_string_new(buffer);").unwrap();
    writeln!(output, "    }}").unwrap();
    writeln!(output, "}}").unwrap();
    writeln!(output).unwrap();

    writeln!(
        output,
        "void qb_input_int(const char* prompt, int32_t* var) {{"
    )
    .unwrap();
    writeln!(output, "    if (prompt) printf(\"%s\", prompt);").unwrap();
    writeln!(output, "    scanf(\"%d\", var);").unwrap();
    writeln!(output, "}}").unwrap();
    writeln!(output).unwrap();

    writeln!(
        output,
        "void qb_input_float(const char* prompt, double* var) {{"
    )
    .unwrap();
    writeln!(output, "    if (prompt) printf(\"%s\", prompt);").unwrap();
    writeln!(output, "    scanf(\"%lf\", var);").unwrap();
    writeln!(output, "}}").unwrap();
    writeln!(output).unwrap();
}

/// Emits string comparison function.
fn emit_string_comparison(output: &mut String) {
    writeln!(
        output,
        "int qb_string_compare(qb_string* a, qb_string* b) {{"
    )
    .unwrap();
    writeln!(output, "    return strcmp(a->data, b->data);").unwrap();
    writeln!(output, "}}").unwrap();
    writeln!(output).unwrap();
}

/// Emits built-in BASIC functions (LEN, CHR$, ASC).
fn emit_builtin_functions(output: &mut String) {
    writeln!(output, "int32_t qb_len(qb_string* s) {{").unwrap();
    writeln!(output, "    return (int32_t)s->len;").unwrap();
    writeln!(output, "}}").unwrap();
    writeln!(output).unwrap();

    writeln!(output, "qb_string* qb_chr(int32_t code) {{").unwrap();
    writeln!(output, "    char buf[2] = {{ (char)code, '\\0' }};").unwrap();
    writeln!(output, "    return qb_string_new(buf);").unwrap();
    writeln!(output, "}}").unwrap();
    writeln!(output).unwrap();

    writeln!(output, "int32_t qb_asc(qb_string* s) {{").unwrap();
    writeln!(
        output,
        "    return s->len > 0 ? (unsigned char)s->data[0] : 0;"
    )
    .unwrap();
    writeln!(output, "}}").unwrap();
    writeln!(output).unwrap();
}

/// Emits math helper functions.
fn emit_math_functions(output: &mut String) {
    writeln!(output, "int32_t qb_sgn(double n) {{").unwrap();
    writeln!(output, "    return (n > 0) - (n < 0);").unwrap();
    writeln!(output, "}}").unwrap();
    writeln!(output).unwrap();

    writeln!(output, "double qb_pi(void) {{").unwrap();
    writeln!(output, "    return 3.14159265358979323846;").unwrap();
    writeln!(output, "}}").unwrap();
    writeln!(output).unwrap();

    writeln!(
        output,
        "double qb_clamp(double value, double min, double max) {{"
    )
    .unwrap();
    writeln!(
        output,
        "    return value < min ? min : (value > max ? max : value);"
    )
    .unwrap();
    writeln!(output, "}}").unwrap();
    writeln!(output).unwrap();

    writeln!(output, "float qb_rnd(float seed) {{").unwrap();
    writeln!(output, "    (void)seed; /* QB RND ignores seed for now */").unwrap();
    writeln!(output, "    return (float)rand() / (float)RAND_MAX;").unwrap();
    writeln!(output, "}}").unwrap();
    writeln!(output).unwrap();
}

/// Emits string manipulation functions (LEFT$, RIGHT$, MID$, etc.).
fn emit_string_manipulation(output: &mut String) {
    // LEFT$(s$, n)
    writeln!(output, "qb_string* qb_left(qb_string* s, int32_t n) {{").unwrap();
    writeln!(output, "    if (n <= 0) return qb_string_new(\"\");").unwrap();
    writeln!(
        output,
        "    size_t len = (size_t)n < s->len ? (size_t)n : s->len;"
    )
    .unwrap();
    writeln!(output, "    qb_string* result = malloc(sizeof(qb_string));").unwrap();
    writeln!(output, "    result->len = len;").unwrap();
    writeln!(output, "    result->capacity = len + 1;").unwrap();
    writeln!(output, "    result->data = malloc(result->capacity);").unwrap();
    writeln!(output, "    memcpy(result->data, s->data, len);").unwrap();
    writeln!(output, "    result->data[len] = '\\0';").unwrap();
    writeln!(output, "    return result;").unwrap();
    writeln!(output, "}}").unwrap();
    writeln!(output).unwrap();

    // RIGHT$(s$, n)
    writeln!(output, "qb_string* qb_right(qb_string* s, int32_t n) {{").unwrap();
    writeln!(output, "    if (n <= 0) return qb_string_new(\"\");").unwrap();
    writeln!(
        output,
        "    size_t len = (size_t)n < s->len ? (size_t)n : s->len;"
    )
    .unwrap();
    writeln!(output, "    size_t start = s->len - len;").unwrap();
    writeln!(output, "    qb_string* result = malloc(sizeof(qb_string));").unwrap();
    writeln!(output, "    result->len = len;").unwrap();
    writeln!(output, "    result->capacity = len + 1;").unwrap();
    writeln!(output, "    result->data = malloc(result->capacity);").unwrap();
    writeln!(output, "    memcpy(result->data, s->data + start, len);").unwrap();
    writeln!(output, "    result->data[len] = '\\0';").unwrap();
    writeln!(output, "    return result;").unwrap();
    writeln!(output, "}}").unwrap();
    writeln!(output).unwrap();

    // MID$(s$, start, len) - 1-based index
    writeln!(
        output,
        "qb_string* qb_mid(qb_string* s, int32_t start, int32_t n) {{"
    )
    .unwrap();
    writeln!(
        output,
        "    if (start < 1 || n <= 0 || (size_t)start > s->len) return qb_string_new(\"\");"
    )
    .unwrap();
    writeln!(output, "    size_t idx = (size_t)(start - 1);").unwrap();
    writeln!(
        output,
        "    size_t len = (idx + (size_t)n > s->len) ? s->len - idx : (size_t)n;"
    )
    .unwrap();
    writeln!(output, "    qb_string* result = malloc(sizeof(qb_string));").unwrap();
    writeln!(output, "    result->len = len;").unwrap();
    writeln!(output, "    result->capacity = len + 1;").unwrap();
    writeln!(output, "    result->data = malloc(result->capacity);").unwrap();
    writeln!(output, "    memcpy(result->data, s->data + idx, len);").unwrap();
    writeln!(output, "    result->data[len] = '\\0';").unwrap();
    writeln!(output, "    return result;").unwrap();
    writeln!(output, "}}").unwrap();
    writeln!(output).unwrap();

    // INSTR(start, s$, find$) - 1-based, returns 0 if not found
    writeln!(
        output,
        "int32_t qb_instr(int32_t start, qb_string* s, qb_string* find) {{"
    )
    .unwrap();
    writeln!(
        output,
        "    if (start < 1 || (size_t)start > s->len || find->len == 0) return 0;"
    )
    .unwrap();
    writeln!(
        output,
        "    char* pos = strstr(s->data + start - 1, find->data);"
    )
    .unwrap();
    writeln!(output, "    return pos ? (int32_t)(pos - s->data + 1) : 0;").unwrap();
    writeln!(output, "}}").unwrap();
    writeln!(output).unwrap();

    // STR$(n) - convert number to string
    writeln!(output, "qb_string* qb_str(double n) {{").unwrap();
    writeln!(output, "    char buf[64];").unwrap();
    writeln!(output, "    snprintf(buf, sizeof(buf), \" %g\", n);").unwrap();
    writeln!(output, "    return qb_string_new(buf);").unwrap();
    writeln!(output, "}}").unwrap();
    writeln!(output).unwrap();

    // VAL(s$) - convert string to number
    writeln!(output, "double qb_val(qb_string* s) {{").unwrap();
    writeln!(output, "    return atof(s->data);").unwrap();
    writeln!(output, "}}").unwrap();
    writeln!(output).unwrap();

    // UCASE$(s$)
    writeln!(output, "qb_string* qb_ucase(qb_string* s) {{").unwrap();
    writeln!(output, "    qb_string* result = malloc(sizeof(qb_string));").unwrap();
    writeln!(output, "    result->len = s->len;").unwrap();
    writeln!(output, "    result->capacity = s->len + 1;").unwrap();
    writeln!(output, "    result->data = malloc(result->capacity);").unwrap();
    writeln!(
        output,
        "    for (size_t i = 0; i < s->len; i++) result->data[i] = toupper(s->data[i]);"
    )
    .unwrap();
    writeln!(output, "    result->data[s->len] = '\\0';").unwrap();
    writeln!(output, "    return result;").unwrap();
    writeln!(output, "}}").unwrap();
    writeln!(output).unwrap();

    // LCASE$(s$)
    writeln!(output, "qb_string* qb_lcase(qb_string* s) {{").unwrap();
    writeln!(output, "    qb_string* result = malloc(sizeof(qb_string));").unwrap();
    writeln!(output, "    result->len = s->len;").unwrap();
    writeln!(output, "    result->capacity = s->len + 1;").unwrap();
    writeln!(output, "    result->data = malloc(result->capacity);").unwrap();
    writeln!(
        output,
        "    for (size_t i = 0; i < s->len; i++) result->data[i] = tolower(s->data[i]);"
    )
    .unwrap();
    writeln!(output, "    result->data[s->len] = '\\0';").unwrap();
    writeln!(output, "    return result;").unwrap();
    writeln!(output, "}}").unwrap();
    writeln!(output).unwrap();

    // LTRIM$(s$)
    writeln!(output, "qb_string* qb_ltrim(qb_string* s) {{").unwrap();
    writeln!(output, "    size_t start = 0;").unwrap();
    writeln!(
        output,
        "    while (start < s->len && s->data[start] == ' ') start++;"
    )
    .unwrap();
    writeln!(output, "    return qb_right(s, (int32_t)(s->len - start));").unwrap();
    writeln!(output, "}}").unwrap();
    writeln!(output).unwrap();

    // RTRIM$(s$)
    writeln!(output, "qb_string* qb_rtrim(qb_string* s) {{").unwrap();
    writeln!(output, "    size_t end = s->len;").unwrap();
    writeln!(
        output,
        "    while (end > 0 && s->data[end - 1] == ' ') end--;"
    )
    .unwrap();
    writeln!(output, "    return qb_left(s, (int32_t)end);").unwrap();
    writeln!(output, "}}").unwrap();
    writeln!(output).unwrap();

    // SPACE$(n)
    writeln!(output, "qb_string* qb_space(int32_t n) {{").unwrap();
    writeln!(output, "    if (n <= 0) return qb_string_new(\"\");").unwrap();
    writeln!(output, "    qb_string* result = malloc(sizeof(qb_string));").unwrap();
    writeln!(output, "    result->len = (size_t)n;").unwrap();
    writeln!(output, "    result->capacity = result->len + 1;").unwrap();
    writeln!(output, "    result->data = malloc(result->capacity);").unwrap();
    writeln!(output, "    memset(result->data, ' ', result->len);").unwrap();
    writeln!(output, "    result->data[result->len] = '\\0';").unwrap();
    writeln!(output, "    return result;").unwrap();
    writeln!(output, "}}").unwrap();
    writeln!(output).unwrap();

    // STRING$(n, char$)
    writeln!(
        output,
        "qb_string* qb_string_fill(int32_t n, qb_string* c) {{"
    )
    .unwrap();
    writeln!(
        output,
        "    if (n <= 0 || c->len == 0) return qb_string_new(\"\");"
    )
    .unwrap();
    writeln!(output, "    qb_string* result = malloc(sizeof(qb_string));").unwrap();
    writeln!(output, "    result->len = (size_t)n;").unwrap();
    writeln!(output, "    result->capacity = result->len + 1;").unwrap();
    writeln!(output, "    result->data = malloc(result->capacity);").unwrap();
    writeln!(output, "    memset(result->data, c->data[0], result->len);").unwrap();
    writeln!(output, "    result->data[result->len] = '\\0';").unwrap();
    writeln!(output, "    return result;").unwrap();
    writeln!(output, "}}").unwrap();
    writeln!(output).unwrap();
}

/// Emits utility functions used by DATA/READ and other constructs.
fn emit_utility_functions(output: &mut String) {
    // qb_str_from_c - create qb_string from C string (alias for qb_string_new)
    writeln!(output, "qb_string* qb_str_from_c(const char* s) {{").unwrap();
    writeln!(output, "    return qb_string_new(s);").unwrap();
    writeln!(output, "}}").unwrap();
    writeln!(output).unwrap();

    // qb_str_float - convert float to string (used by DATA/READ)
    writeln!(output, "qb_string* qb_str_float(double n) {{").unwrap();
    writeln!(output, "    char buf[64];").unwrap();
    writeln!(output, "    snprintf(buf, sizeof(buf), \"%g\", n);").unwrap();
    writeln!(output, "    return qb_string_new(buf);").unwrap();
    writeln!(output, "}}").unwrap();
    writeln!(output).unwrap();
}

/// Emits file I/O functions for OPEN, CLOSE, PRINT #, INPUT #, etc.
fn emit_file_io_functions(output: &mut String) {
    writeln!(output, "/* File I/O Functions */").unwrap();
    writeln!(output).unwrap();

    // File handle table (max 511 files as per QB64)
    writeln!(output, "#define QB_MAX_FILES 512").unwrap();
    writeln!(output, "static FILE* _qb_files[QB_MAX_FILES];").unwrap();
    writeln!(output, "static int32_t _qb_file_reclen[QB_MAX_FILES];").unwrap();
    writeln!(output).unwrap();

    // qb_file_open - Open a file
    writeln!(
        output,
        "void qb_file_open(int32_t fnum, const char* filename, const char* mode) {{"
    )
    .unwrap();
    writeln!(output, "    if (fnum < 1 || fnum >= QB_MAX_FILES) return;").unwrap();
    writeln!(output, "    if (_qb_files[fnum]) fclose(_qb_files[fnum]);").unwrap();
    writeln!(output, "    _qb_files[fnum] = fopen(filename, mode);").unwrap();
    writeln!(
        output,
        "    _qb_file_reclen[fnum] = 128; /* default record length */"
    )
    .unwrap();
    writeln!(output, "}}").unwrap();
    writeln!(output).unwrap();

    // qb_file_set_reclen - Set record length for random access
    writeln!(
        output,
        "void qb_file_set_reclen(int32_t fnum, int32_t len) {{"
    )
    .unwrap();
    writeln!(
        output,
        "    if (fnum >= 1 && fnum < QB_MAX_FILES) _qb_file_reclen[fnum] = len;"
    )
    .unwrap();
    writeln!(output, "}}").unwrap();
    writeln!(output).unwrap();

    // qb_file_close - Close a file
    writeln!(output, "void qb_file_close(int32_t fnum) {{").unwrap();
    writeln!(
        output,
        "    if (fnum >= 1 && fnum < QB_MAX_FILES && _qb_files[fnum]) {{"
    )
    .unwrap();
    writeln!(output, "        fclose(_qb_files[fnum]);").unwrap();
    writeln!(output, "        _qb_files[fnum] = NULL;").unwrap();
    writeln!(output, "    }}").unwrap();
    writeln!(output, "}}").unwrap();
    writeln!(output).unwrap();

    // qb_file_close_all - Close all files
    writeln!(output, "void qb_file_close_all(void) {{").unwrap();
    writeln!(output, "    for (int i = 1; i < QB_MAX_FILES; i++) {{").unwrap();
    writeln!(
        output,
        "        if (_qb_files[i]) {{ fclose(_qb_files[i]); _qb_files[i] = NULL; }}"
    )
    .unwrap();
    writeln!(output, "    }}").unwrap();
    writeln!(output, "}}").unwrap();
    writeln!(output).unwrap();

    // qb_file_print_* - Print to file
    writeln!(
        output,
        "void qb_file_print_int(int32_t fnum, int64_t val) {{"
    )
    .unwrap();
    writeln!(
        output,
        "    if (fnum >= 1 && fnum < QB_MAX_FILES && _qb_files[fnum])"
    )
    .unwrap();
    writeln!(
        output,
        "        fprintf(_qb_files[fnum], \"%lld\", (long long)val);"
    )
    .unwrap();
    writeln!(output, "}}").unwrap();
    writeln!(output).unwrap();

    writeln!(
        output,
        "void qb_file_print_float(int32_t fnum, double val) {{"
    )
    .unwrap();
    writeln!(
        output,
        "    if (fnum >= 1 && fnum < QB_MAX_FILES && _qb_files[fnum])"
    )
    .unwrap();
    writeln!(output, "        fprintf(_qb_files[fnum], \"%g\", val);").unwrap();
    writeln!(output, "}}").unwrap();
    writeln!(output).unwrap();

    writeln!(
        output,
        "void qb_file_print_string(int32_t fnum, qb_string* s) {{"
    )
    .unwrap();
    writeln!(
        output,
        "    if (fnum >= 1 && fnum < QB_MAX_FILES && _qb_files[fnum] && s)"
    )
    .unwrap();
    writeln!(output, "        fprintf(_qb_files[fnum], \"%s\", s->data);").unwrap();
    writeln!(output, "}}").unwrap();
    writeln!(output).unwrap();

    writeln!(output, "void qb_file_print_newline(int32_t fnum) {{").unwrap();
    writeln!(
        output,
        "    if (fnum >= 1 && fnum < QB_MAX_FILES && _qb_files[fnum])"
    )
    .unwrap();
    writeln!(output, "        fprintf(_qb_files[fnum], \"\\n\");").unwrap();
    writeln!(output, "}}").unwrap();
    writeln!(output).unwrap();

    writeln!(output, "void qb_file_print_tab(int32_t fnum) {{").unwrap();
    writeln!(
        output,
        "    if (fnum >= 1 && fnum < QB_MAX_FILES && _qb_files[fnum])"
    )
    .unwrap();
    writeln!(output, "        fprintf(_qb_files[fnum], \"\\t\");").unwrap();
    writeln!(output, "}}").unwrap();
    writeln!(output).unwrap();

    // qb_file_write_* - WRITE # functions (quoted strings, comma-separated)
    writeln!(
        output,
        "void qb_file_write_string(int32_t fnum, qb_string* s) {{"
    )
    .unwrap();
    writeln!(
        output,
        "    if (fnum >= 1 && fnum < QB_MAX_FILES && _qb_files[fnum] && s)"
    )
    .unwrap();
    writeln!(
        output,
        "        fprintf(_qb_files[fnum], \"\\\"%s\\\"\", s->data);"
    )
    .unwrap();
    writeln!(output, "}}").unwrap();
    writeln!(output).unwrap();

    writeln!(
        output,
        "void qb_file_write_number(int32_t fnum, double val) {{"
    )
    .unwrap();
    writeln!(
        output,
        "    if (fnum >= 1 && fnum < QB_MAX_FILES && _qb_files[fnum])"
    )
    .unwrap();
    writeln!(output, "        fprintf(_qb_files[fnum], \"%g\", val);").unwrap();
    writeln!(output, "}}").unwrap();
    writeln!(output).unwrap();

    writeln!(output, "void qb_file_write_char(int32_t fnum, char c) {{").unwrap();
    writeln!(
        output,
        "    if (fnum >= 1 && fnum < QB_MAX_FILES && _qb_files[fnum])"
    )
    .unwrap();
    writeln!(output, "        fputc(c, _qb_files[fnum]);").unwrap();
    writeln!(output, "}}").unwrap();
    writeln!(output).unwrap();

    // qb_file_input_* - INPUT # functions
    writeln!(
        output,
        "void qb_file_input_string(int32_t fnum, qb_string** s) {{"
    )
    .unwrap();
    writeln!(
        output,
        "    if (fnum < 1 || fnum >= QB_MAX_FILES || !_qb_files[fnum]) return;"
    )
    .unwrap();
    writeln!(output, "    char buf[4096];").unwrap();
    writeln!(output, "    int ch, i = 0;").unwrap();
    writeln!(output, "    while ((ch = fgetc(_qb_files[fnum])) != EOF && ch != ',' && ch != '\\n' && i < 4095) {{").unwrap();
    writeln!(output, "        if (ch == '\"') {{ /* skip quotes */").unwrap();
    writeln!(
        output,
        "            while ((ch = fgetc(_qb_files[fnum])) != EOF && ch != '\"' && i < 4095)"
    )
    .unwrap();
    writeln!(output, "                buf[i++] = (char)ch;").unwrap();
    writeln!(output, "        }} else buf[i++] = (char)ch;").unwrap();
    writeln!(output, "    }}").unwrap();
    writeln!(output, "    buf[i] = '\\0';").unwrap();
    writeln!(output, "    *s = qb_string_new(buf);").unwrap();
    writeln!(output, "}}").unwrap();
    writeln!(output).unwrap();

    writeln!(
        output,
        "void qb_file_input_int(int32_t fnum, int32_t* val) {{"
    )
    .unwrap();
    writeln!(
        output,
        "    if (fnum < 1 || fnum >= QB_MAX_FILES || !_qb_files[fnum]) return;"
    )
    .unwrap();
    writeln!(output, "    fscanf(_qb_files[fnum], \"%d\", val);").unwrap();
    writeln!(
        output,
        "    int ch; while ((ch = fgetc(_qb_files[fnum])) == ',' || ch == ' ');"
    )
    .unwrap();
    writeln!(
        output,
        "    if (ch != EOF && ch != '\\n') ungetc(ch, _qb_files[fnum]);"
    )
    .unwrap();
    writeln!(output, "}}").unwrap();
    writeln!(output).unwrap();

    writeln!(
        output,
        "void qb_file_input_float(int32_t fnum, double* val) {{"
    )
    .unwrap();
    writeln!(
        output,
        "    if (fnum < 1 || fnum >= QB_MAX_FILES || !_qb_files[fnum]) return;"
    )
    .unwrap();
    writeln!(output, "    fscanf(_qb_files[fnum], \"%lf\", val);").unwrap();
    writeln!(
        output,
        "    int ch; while ((ch = fgetc(_qb_files[fnum])) == ',' || ch == ' ');"
    )
    .unwrap();
    writeln!(
        output,
        "    if (ch != EOF && ch != '\\n') ungetc(ch, _qb_files[fnum]);"
    )
    .unwrap();
    writeln!(output, "}}").unwrap();
    writeln!(output).unwrap();

    // qb_file_line_input - LINE INPUT #
    writeln!(
        output,
        "void qb_file_line_input(int32_t fnum, qb_string** s) {{"
    )
    .unwrap();
    writeln!(
        output,
        "    if (fnum < 1 || fnum >= QB_MAX_FILES || !_qb_files[fnum]) return;"
    )
    .unwrap();
    writeln!(output, "    char buf[4096];").unwrap();
    writeln!(
        output,
        "    if (fgets(buf, sizeof(buf), _qb_files[fnum])) {{"
    )
    .unwrap();
    writeln!(output, "        size_t len = strlen(buf);").unwrap();
    writeln!(
        output,
        "        if (len > 0 && buf[len-1] == '\\n') buf[--len] = '\\0';"
    )
    .unwrap();
    writeln!(output, "        *s = qb_string_new(buf);").unwrap();
    writeln!(output, "    }} else *s = qb_string_new(\"\");").unwrap();
    writeln!(output, "}}").unwrap();
    writeln!(output).unwrap();

    // Binary file operations
    writeln!(output, "void qb_file_seek(int32_t fnum, int64_t pos) {{").unwrap();
    writeln!(
        output,
        "    if (fnum >= 1 && fnum < QB_MAX_FILES && _qb_files[fnum])"
    )
    .unwrap();
    writeln!(
        output,
        "        fseek(_qb_files[fnum], (long)(pos - 1), SEEK_SET);"
    )
    .unwrap();
    writeln!(output, "}}").unwrap();
    writeln!(output).unwrap();

    writeln!(
        output,
        "void qb_file_seek_record(int32_t fnum, int64_t rec) {{"
    )
    .unwrap();
    writeln!(
        output,
        "    if (fnum >= 1 && fnum < QB_MAX_FILES && _qb_files[fnum])"
    )
    .unwrap();
    writeln!(
        output,
        "        fseek(_qb_files[fnum], (long)((rec - 1) * _qb_file_reclen[fnum]), SEEK_SET);"
    )
    .unwrap();
    writeln!(output, "}}").unwrap();
    writeln!(output).unwrap();

    writeln!(
        output,
        "void qb_file_get(int32_t fnum, void* data, size_t size) {{"
    )
    .unwrap();
    writeln!(
        output,
        "    if (fnum >= 1 && fnum < QB_MAX_FILES && _qb_files[fnum])"
    )
    .unwrap();
    writeln!(output, "        fread(data, 1, size, _qb_files[fnum]);").unwrap();
    writeln!(output, "}}").unwrap();
    writeln!(output).unwrap();

    writeln!(
        output,
        "void qb_file_put(int32_t fnum, const void* data, size_t size) {{"
    )
    .unwrap();
    writeln!(
        output,
        "    if (fnum >= 1 && fnum < QB_MAX_FILES && _qb_files[fnum])"
    )
    .unwrap();
    writeln!(output, "        fwrite(data, 1, size, _qb_files[fnum]);").unwrap();
    writeln!(output, "}}").unwrap();
    writeln!(output).unwrap();

    // File functions
    writeln!(output, "int32_t qb_eof(int32_t fnum) {{").unwrap();
    writeln!(
        output,
        "    if (fnum >= 1 && fnum < QB_MAX_FILES && _qb_files[fnum])"
    )
    .unwrap();
    writeln!(output, "        return feof(_qb_files[fnum]) ? -1 : 0;").unwrap();
    writeln!(output, "    return -1;").unwrap();
    writeln!(output, "}}").unwrap();
    writeln!(output).unwrap();

    writeln!(output, "int64_t qb_lof(int32_t fnum) {{").unwrap();
    writeln!(
        output,
        "    if (fnum < 1 || fnum >= QB_MAX_FILES || !_qb_files[fnum]) return 0;"
    )
    .unwrap();
    writeln!(output, "    long pos = ftell(_qb_files[fnum]);").unwrap();
    writeln!(output, "    fseek(_qb_files[fnum], 0, SEEK_END);").unwrap();
    writeln!(output, "    long len = ftell(_qb_files[fnum]);").unwrap();
    writeln!(output, "    fseek(_qb_files[fnum], pos, SEEK_SET);").unwrap();
    writeln!(output, "    return (int64_t)len;").unwrap();
    writeln!(output, "}}").unwrap();
    writeln!(output).unwrap();

    writeln!(output, "int64_t qb_loc(int32_t fnum) {{").unwrap();
    writeln!(
        output,
        "    if (fnum >= 1 && fnum < QB_MAX_FILES && _qb_files[fnum])"
    )
    .unwrap();
    writeln!(
        output,
        "        return (int64_t)ftell(_qb_files[fnum]) + 1;"
    )
    .unwrap();
    writeln!(output, "    return 0;").unwrap();
    writeln!(output, "}}").unwrap();
    writeln!(output).unwrap();

    writeln!(output, "int32_t qb_freefile(void) {{").unwrap();
    writeln!(output, "    for (int i = 1; i < QB_MAX_FILES; i++)").unwrap();
    writeln!(output, "        if (!_qb_files[i]) return i;").unwrap();
    writeln!(output, "    return 0;").unwrap();
    writeln!(output, "}}").unwrap();
    writeln!(output).unwrap();
}

/// Emits error handling support for ON ERROR, RESUME, ERR, ERL.
fn emit_error_handling(output: &mut String) {
    writeln!(output, "/* Error Handling */").unwrap();
    writeln!(output).unwrap();

    // Error state variables
    writeln!(
        output,
        "static int32_t _qb_err = 0;           /* Current error code */"
    )
    .unwrap();
    writeln!(
        output,
        "static int32_t _qb_erl = 0;           /* Error line number */"
    )
    .unwrap();
    writeln!(
        output,
        "static void* _qb_error_handler = NULL; /* Error handler label */"
    )
    .unwrap();
    writeln!(
        output,
        "static int _qb_error_resume_next = 0;  /* ON ERROR RESUME NEXT flag */"
    )
    .unwrap();
    writeln!(
        output,
        "static void* _qb_error_line = NULL;    /* Line that caused error */"
    )
    .unwrap();
    writeln!(output).unwrap();

    // qb_error - Simulate an error
    writeln!(output, "void qb_error(int32_t code) {{").unwrap();
    writeln!(output, "    _qb_err = code;").unwrap();
    writeln!(output, "    if (_qb_error_handler) {{").unwrap();
    writeln!(
        output,
        "        /* Jump to error handler - handled by generated code */"
    )
    .unwrap();
    writeln!(output, "    }}").unwrap();
    writeln!(output, "}}").unwrap();
    writeln!(output).unwrap();

    // ERR function
    writeln!(output, "int32_t qb_err_code(void) {{ return _qb_err; }}").unwrap();
    writeln!(output).unwrap();

    // ERL function
    writeln!(output, "int32_t qb_err_line(void) {{ return _qb_erl; }}").unwrap();
    writeln!(output).unwrap();
}

/// Emits keyboard input functions for INKEY$, INPUT$, etc.
fn emit_keyboard_functions(output: &mut String) {
    writeln!(output, "/* Keyboard Input Functions */").unwrap();
    writeln!(output).unwrap();

    // Platform-specific non-blocking key check
    writeln!(output, "#ifdef _WIN32").unwrap();
    writeln!(output, "#include <conio.h>").unwrap();
    writeln!(output, "qb_string* qb_inkey(void) {{").unwrap();
    writeln!(output, "    if (_kbhit()) {{").unwrap();
    writeln!(output, "        int ch = _getch();").unwrap();
    writeln!(output, "        if (ch == 0 || ch == 224) {{").unwrap();
    writeln!(
        output,
        "            char buf[3] = {{0, (char)_getch(), 0}};"
    )
    .unwrap();
    writeln!(output, "            return qb_string_new(buf);").unwrap();
    writeln!(output, "        }}").unwrap();
    writeln!(output, "        char buf[2] = {{(char)ch, 0}};").unwrap();
    writeln!(output, "        return qb_string_new(buf);").unwrap();
    writeln!(output, "    }}").unwrap();
    writeln!(output, "    return qb_string_new(\"\");").unwrap();
    writeln!(output, "}}").unwrap();
    writeln!(output, "#else").unwrap();
    writeln!(output, "#include <termios.h>").unwrap();
    writeln!(output, "#include <unistd.h>").unwrap();
    writeln!(output, "#include <sys/select.h>").unwrap();
    writeln!(output, "qb_string* qb_inkey(void) {{").unwrap();
    writeln!(output, "    struct termios oldt, newt;").unwrap();
    writeln!(output, "    tcgetattr(STDIN_FILENO, &oldt);").unwrap();
    writeln!(output, "    newt = oldt;").unwrap();
    writeln!(output, "    newt.c_lflag &= ~(ICANON | ECHO);").unwrap();
    writeln!(output, "    tcsetattr(STDIN_FILENO, TCSANOW, &newt);").unwrap();
    writeln!(output, "    fd_set fds; struct timeval tv = {{0, 0}};").unwrap();
    writeln!(output, "    FD_ZERO(&fds); FD_SET(STDIN_FILENO, &fds);").unwrap();
    writeln!(output, "    qb_string* result = qb_string_new(\"\");").unwrap();
    writeln!(
        output,
        "    if (select(STDIN_FILENO + 1, &fds, NULL, NULL, &tv) > 0) {{"
    )
    .unwrap();
    writeln!(output, "        char buf[4] = {{0}};").unwrap();
    writeln!(
        output,
        "        int n = read(STDIN_FILENO, buf, sizeof(buf)-1);"
    )
    .unwrap();
    writeln!(output, "        if (n > 0) result = qb_string_new(buf);").unwrap();
    writeln!(output, "    }}").unwrap();
    writeln!(output, "    tcsetattr(STDIN_FILENO, TCSANOW, &oldt);").unwrap();
    writeln!(output, "    return result;").unwrap();
    writeln!(output, "}}").unwrap();
    writeln!(output, "#endif").unwrap();
    writeln!(output).unwrap();

    // INPUT$(n) - read n characters
    writeln!(output, "qb_string* qb_input_chars(int32_t n) {{").unwrap();
    writeln!(output, "    if (n <= 0) return qb_string_new(\"\");").unwrap();
    writeln!(output, "    char* buf = malloc((size_t)n + 1);").unwrap();
    writeln!(
        output,
        "    for (int32_t i = 0; i < n; i++) buf[i] = (char)getchar();"
    )
    .unwrap();
    writeln!(output, "    buf[n] = '\\0';").unwrap();
    writeln!(output, "    qb_string* result = qb_string_new(buf);").unwrap();
    writeln!(output, "    free(buf);").unwrap();
    writeln!(output, "    return result;").unwrap();
    writeln!(output, "}}").unwrap();
    writeln!(output).unwrap();

    // INPUT$(n, #fnum) - read n characters from file
    writeln!(
        output,
        "qb_string* qb_input_chars_file(int32_t n, int32_t fnum) {{"
    )
    .unwrap();
    writeln!(
        output,
        "    if (n <= 0 || fnum < 1 || fnum >= QB_MAX_FILES || !_qb_files[fnum])"
    )
    .unwrap();
    writeln!(output, "        return qb_string_new(\"\");").unwrap();
    writeln!(output, "    char* buf = malloc((size_t)n + 1);").unwrap();
    writeln!(
        output,
        "    size_t read = fread(buf, 1, (size_t)n, _qb_files[fnum]);"
    )
    .unwrap();
    writeln!(output, "    buf[read] = '\\0';").unwrap();
    writeln!(output, "    qb_string* result = qb_string_new(buf);").unwrap();
    writeln!(output, "    free(buf);").unwrap();
    writeln!(output, "    return result;").unwrap();
    writeln!(output, "}}").unwrap();
    writeln!(output).unwrap();

    // Environment functions
    writeln!(output, "/* Environment Functions */").unwrap();
    writeln!(output).unwrap();

    // ENVIRON$(var$) - get environment variable
    writeln!(output, "qb_string* qb_environ(qb_string* var) {{").unwrap();
    writeln!(
        output,
        "    if (!var || !var->data) return qb_string_new(\"\");"
    )
    .unwrap();
    writeln!(output, "    const char* val = getenv(var->data);").unwrap();
    writeln!(
        output,
        "    return val ? qb_string_new(val) : qb_string_new(\"\");"
    )
    .unwrap();
    writeln!(output, "}}").unwrap();
    writeln!(output).unwrap();

    // COMMAND$ - get command line arguments
    writeln!(output, "static int _qb_argc = 0;").unwrap();
    writeln!(output, "static char** _qb_argv = NULL;").unwrap();
    writeln!(
        output,
        "void qb_init_args(int argc, char** argv) {{ _qb_argc = argc; _qb_argv = argv; }}"
    )
    .unwrap();
    writeln!(output).unwrap();

    writeln!(output, "qb_string* qb_command(void) {{").unwrap();
    writeln!(
        output,
        "    if (_qb_argc <= 1 || !_qb_argv) return qb_string_new(\"\");"
    )
    .unwrap();
    writeln!(output, "    size_t len = 0;").unwrap();
    writeln!(
        output,
        "    for (int i = 1; i < _qb_argc; i++) len += strlen(_qb_argv[i]) + 1;"
    )
    .unwrap();
    writeln!(output, "    char* buf = malloc(len + 1);").unwrap();
    writeln!(output, "    buf[0] = '\\0';").unwrap();
    writeln!(output, "    for (int i = 1; i < _qb_argc; i++) {{").unwrap();
    writeln!(output, "        if (i > 1) strcat(buf, \" \");").unwrap();
    writeln!(output, "        strcat(buf, _qb_argv[i]);").unwrap();
    writeln!(output, "    }}").unwrap();
    writeln!(output, "    qb_string* result = qb_string_new(buf);").unwrap();
    writeln!(output, "    free(buf);").unwrap();
    writeln!(output, "    return result;").unwrap();
    writeln!(output, "}}").unwrap();
    writeln!(output).unwrap();

    // _CWD$ - current working directory
    writeln!(output, "#ifdef _WIN32").unwrap();
    writeln!(output, "#include <direct.h>").unwrap();
    writeln!(output, "#define getcwd _getcwd").unwrap();
    writeln!(output, "#endif").unwrap();
    writeln!(output, "qb_string* qb_cwd(void) {{").unwrap();
    writeln!(output, "    char buf[4096];").unwrap();
    writeln!(
        output,
        "    if (getcwd(buf, sizeof(buf))) return qb_string_new(buf);"
    )
    .unwrap();
    writeln!(output, "    return qb_string_new(\"\");").unwrap();
    writeln!(output, "}}").unwrap();
    writeln!(output).unwrap();

    // _OS$ - operating system
    writeln!(output, "qb_string* qb_os(void) {{").unwrap();
    writeln!(output, "#ifdef _WIN32").unwrap();
    writeln!(output, "    return qb_string_new(\"WINDOWS\");").unwrap();
    writeln!(output, "#elif defined(__APPLE__)").unwrap();
    writeln!(output, "    return qb_string_new(\"MACOSX\");").unwrap();
    writeln!(output, "#else").unwrap();
    writeln!(output, "    return qb_string_new(\"LINUX\");").unwrap();
    writeln!(output, "#endif").unwrap();
    writeln!(output, "}}").unwrap();
    writeln!(output).unwrap();

    // _STARTDIR$ - program start directory
    writeln!(output, "static char _qb_startdir[4096] = {{}};").unwrap();
    writeln!(
        output,
        "void qb_init_startdir(void) {{ getcwd(_qb_startdir, sizeof(_qb_startdir)); }}"
    )
    .unwrap();
    writeln!(
        output,
        "qb_string* qb_startdir(void) {{ return qb_string_new(_qb_startdir); }}"
    )
    .unwrap();
    writeln!(output).unwrap();
}
