//! Runtime library code generation for QB64Fresh C backend.
//!
//! This module generates the inline runtime library declarations that provide
//! the core functionality for QB64Fresh programs: string handling, I/O operations,
//! math functions, and built-in QB64 functions.
//!
//! When `RuntimeMode::Inline` is selected, these functions are embedded directly
//! in the generated C code, making the output self-contained and portable.
//!
//! When `RuntimeMode::External` is selected, the generated code instead includes
//! a header file reference to link against the external runtime library.

use std::fmt::Write;

use super::RuntimeMode;

/// Emits the header section including runtime declarations.
///
/// This function writes the standard includes and either inline runtime code
/// or external library references based on the configured runtime mode.
pub(super) fn emit_header(output: &mut String, runtime_mode: RuntimeMode) {
    writeln!(output, "/* Generated by QB64Fresh */").unwrap();
    writeln!(output, "#include <stdio.h>").unwrap();
    writeln!(output, "#include <stdlib.h>").unwrap();
    writeln!(output, "#include <stdint.h>").unwrap();
    writeln!(output, "#include <stdbool.h>").unwrap();
    writeln!(output, "#include <string.h>").unwrap();
    writeln!(output, "#include <math.h>").unwrap();
    writeln!(output, "#include <ctype.h>").unwrap();
    writeln!(output).unwrap();

    match runtime_mode {
        RuntimeMode::Inline => {
            // Inline runtime library declarations
            emit_runtime_declarations(output);
        }
        RuntimeMode::External => {
            // Use external runtime library
            writeln!(output, "#include \"qb64fresh_rt.h\"").unwrap();
            writeln!(output).unwrap();
            // Alias for compatibility with inline code style
            writeln!(output, "typedef QbString qb_string;").unwrap();
            writeln!(output).unwrap();
            writeln!(output, "/* Using external QB64Fresh runtime library */").unwrap();
            writeln!(
                output,
                "/* Compile with: gcc -I<include_path> program.c -L<lib_path> -lqb64fresh_rt */"
            )
            .unwrap();
            writeln!(output).unwrap();
        }
    }
}

/// Emits the complete inline runtime library declarations.
///
/// This includes:
/// - String type definition and operations (allocation, concatenation, comparison)
/// - PRINT functions for different types
/// - INPUT functions for user input
/// - Built-in string functions (LEN, CHR$, ASC, LEFT$, RIGHT$, MID$, etc.)
/// - Math helper functions (SGN, PI, RND, CLAMP)
fn emit_runtime_declarations(output: &mut String) {
    writeln!(output, "/* QB64Fresh Runtime Library */").unwrap();
    writeln!(output).unwrap();

    emit_string_type(output);
    emit_string_functions(output);
    emit_print_functions(output);
    emit_input_functions(output);
    emit_string_comparison(output);
    emit_builtin_functions(output);
    emit_math_functions(output);
    emit_string_manipulation(output);
    emit_utility_functions(output);
}

/// Emits the qb_string type definition.
fn emit_string_type(output: &mut String) {
    writeln!(output, "typedef struct qb_string {{").unwrap();
    writeln!(output, "    char* data;").unwrap();
    writeln!(output, "    size_t len;").unwrap();
    writeln!(output, "    size_t capacity;").unwrap();
    writeln!(output, "}} qb_string;").unwrap();
    writeln!(output).unwrap();
}

/// Emits core string allocation and manipulation functions.
fn emit_string_functions(output: &mut String) {
    // String creation
    writeln!(output, "qb_string* qb_string_new(const char* s) {{").unwrap();
    writeln!(output, "    qb_string* str = malloc(sizeof(qb_string));").unwrap();
    writeln!(output, "    str->len = strlen(s);").unwrap();
    writeln!(output, "    str->capacity = str->len + 1;").unwrap();
    writeln!(output, "    str->data = malloc(str->capacity);").unwrap();
    writeln!(output, "    memcpy(str->data, s, str->len + 1);").unwrap();
    writeln!(output, "    return str;").unwrap();
    writeln!(output, "}}").unwrap();
    writeln!(output).unwrap();

    // String deallocation
    writeln!(output, "void qb_string_free(qb_string* s) {{").unwrap();
    writeln!(output, "    if (s) {{ free(s->data); free(s); }}").unwrap();
    writeln!(output, "}}").unwrap();
    writeln!(output).unwrap();

    // String concatenation
    writeln!(
        output,
        "qb_string* qb_string_concat(qb_string* a, qb_string* b) {{"
    )
    .unwrap();
    writeln!(output, "    qb_string* result = malloc(sizeof(qb_string));").unwrap();
    writeln!(output, "    result->len = a->len + b->len;").unwrap();
    writeln!(output, "    result->capacity = result->len + 1;").unwrap();
    writeln!(output, "    result->data = malloc(result->capacity);").unwrap();
    writeln!(output, "    memcpy(result->data, a->data, a->len);").unwrap();
    writeln!(
        output,
        "    memcpy(result->data + a->len, b->data, b->len + 1);"
    )
    .unwrap();
    writeln!(output, "    return result;").unwrap();
    writeln!(output, "}}").unwrap();
    writeln!(output).unwrap();
}

/// Emits PRINT functions for different data types.
fn emit_print_functions(output: &mut String) {
    writeln!(output, "void qb_print_int(int64_t n) {{").unwrap();
    writeln!(output, "    printf(\"%lld\", (long long)n);").unwrap();
    writeln!(output, "}}").unwrap();
    writeln!(output).unwrap();

    writeln!(output, "void qb_print_float(double n) {{").unwrap();
    writeln!(output, "    printf(\"%g\", n);").unwrap();
    writeln!(output, "}}").unwrap();
    writeln!(output).unwrap();

    writeln!(output, "void qb_print_string(qb_string* s) {{").unwrap();
    writeln!(output, "    printf(\"%s\", s->data);").unwrap();
    writeln!(output, "}}").unwrap();
    writeln!(output).unwrap();

    writeln!(output, "void qb_print_newline(void) {{").unwrap();
    writeln!(output, "    printf(\"\\n\");").unwrap();
    writeln!(output, "}}").unwrap();
    writeln!(output).unwrap();

    writeln!(output, "void qb_print_tab(void) {{").unwrap();
    writeln!(output, "    printf(\"\\t\");").unwrap();
    writeln!(output, "}}").unwrap();
    writeln!(output).unwrap();
}

/// Emits INPUT functions for reading user input.
fn emit_input_functions(output: &mut String) {
    writeln!(
        output,
        "void qb_input_string(const char* prompt, qb_string** var) {{"
    )
    .unwrap();
    writeln!(output, "    char buffer[1024];").unwrap();
    writeln!(output, "    if (prompt) printf(\"%s\", prompt);").unwrap();
    writeln!(output, "    if (fgets(buffer, sizeof(buffer), stdin)) {{").unwrap();
    writeln!(output, "        size_t len = strlen(buffer);").unwrap();
    writeln!(
        output,
        "        if (len > 0 && buffer[len-1] == '\\n') buffer[len-1] = '\\0';"
    )
    .unwrap();
    writeln!(output, "        if (*var) qb_string_free(*var);").unwrap();
    writeln!(output, "        *var = qb_string_new(buffer);").unwrap();
    writeln!(output, "    }}").unwrap();
    writeln!(output, "}}").unwrap();
    writeln!(output).unwrap();

    writeln!(
        output,
        "void qb_input_int(const char* prompt, int32_t* var) {{"
    )
    .unwrap();
    writeln!(output, "    if (prompt) printf(\"%s\", prompt);").unwrap();
    writeln!(output, "    scanf(\"%d\", var);").unwrap();
    writeln!(output, "}}").unwrap();
    writeln!(output).unwrap();

    writeln!(
        output,
        "void qb_input_float(const char* prompt, double* var) {{"
    )
    .unwrap();
    writeln!(output, "    if (prompt) printf(\"%s\", prompt);").unwrap();
    writeln!(output, "    scanf(\"%lf\", var);").unwrap();
    writeln!(output, "}}").unwrap();
    writeln!(output).unwrap();
}

/// Emits string comparison function.
fn emit_string_comparison(output: &mut String) {
    writeln!(
        output,
        "int qb_string_compare(qb_string* a, qb_string* b) {{"
    )
    .unwrap();
    writeln!(output, "    return strcmp(a->data, b->data);").unwrap();
    writeln!(output, "}}").unwrap();
    writeln!(output).unwrap();
}

/// Emits built-in BASIC functions (LEN, CHR$, ASC).
fn emit_builtin_functions(output: &mut String) {
    writeln!(output, "int32_t qb_len(qb_string* s) {{").unwrap();
    writeln!(output, "    return (int32_t)s->len;").unwrap();
    writeln!(output, "}}").unwrap();
    writeln!(output).unwrap();

    writeln!(output, "qb_string* qb_chr(int32_t code) {{").unwrap();
    writeln!(output, "    char buf[2] = {{ (char)code, '\\0' }};").unwrap();
    writeln!(output, "    return qb_string_new(buf);").unwrap();
    writeln!(output, "}}").unwrap();
    writeln!(output).unwrap();

    writeln!(output, "int32_t qb_asc(qb_string* s) {{").unwrap();
    writeln!(
        output,
        "    return s->len > 0 ? (unsigned char)s->data[0] : 0;"
    )
    .unwrap();
    writeln!(output, "}}").unwrap();
    writeln!(output).unwrap();
}

/// Emits math helper functions.
fn emit_math_functions(output: &mut String) {
    writeln!(output, "int32_t qb_sgn(double n) {{").unwrap();
    writeln!(output, "    return (n > 0) - (n < 0);").unwrap();
    writeln!(output, "}}").unwrap();
    writeln!(output).unwrap();

    writeln!(output, "double qb_pi(void) {{").unwrap();
    writeln!(output, "    return 3.14159265358979323846;").unwrap();
    writeln!(output, "}}").unwrap();
    writeln!(output).unwrap();

    writeln!(
        output,
        "double qb_clamp(double value, double min, double max) {{"
    )
    .unwrap();
    writeln!(
        output,
        "    return value < min ? min : (value > max ? max : value);"
    )
    .unwrap();
    writeln!(output, "}}").unwrap();
    writeln!(output).unwrap();

    writeln!(output, "float qb_rnd(float seed) {{").unwrap();
    writeln!(output, "    (void)seed; /* QB RND ignores seed for now */").unwrap();
    writeln!(output, "    return (float)rand() / (float)RAND_MAX;").unwrap();
    writeln!(output, "}}").unwrap();
    writeln!(output).unwrap();
}

/// Emits string manipulation functions (LEFT$, RIGHT$, MID$, etc.).
fn emit_string_manipulation(output: &mut String) {
    // LEFT$(s$, n)
    writeln!(output, "qb_string* qb_left(qb_string* s, int32_t n) {{").unwrap();
    writeln!(output, "    if (n <= 0) return qb_string_new(\"\");").unwrap();
    writeln!(
        output,
        "    size_t len = (size_t)n < s->len ? (size_t)n : s->len;"
    )
    .unwrap();
    writeln!(output, "    qb_string* result = malloc(sizeof(qb_string));").unwrap();
    writeln!(output, "    result->len = len;").unwrap();
    writeln!(output, "    result->capacity = len + 1;").unwrap();
    writeln!(output, "    result->data = malloc(result->capacity);").unwrap();
    writeln!(output, "    memcpy(result->data, s->data, len);").unwrap();
    writeln!(output, "    result->data[len] = '\\0';").unwrap();
    writeln!(output, "    return result;").unwrap();
    writeln!(output, "}}").unwrap();
    writeln!(output).unwrap();

    // RIGHT$(s$, n)
    writeln!(output, "qb_string* qb_right(qb_string* s, int32_t n) {{").unwrap();
    writeln!(output, "    if (n <= 0) return qb_string_new(\"\");").unwrap();
    writeln!(
        output,
        "    size_t len = (size_t)n < s->len ? (size_t)n : s->len;"
    )
    .unwrap();
    writeln!(output, "    size_t start = s->len - len;").unwrap();
    writeln!(output, "    qb_string* result = malloc(sizeof(qb_string));").unwrap();
    writeln!(output, "    result->len = len;").unwrap();
    writeln!(output, "    result->capacity = len + 1;").unwrap();
    writeln!(output, "    result->data = malloc(result->capacity);").unwrap();
    writeln!(output, "    memcpy(result->data, s->data + start, len);").unwrap();
    writeln!(output, "    result->data[len] = '\\0';").unwrap();
    writeln!(output, "    return result;").unwrap();
    writeln!(output, "}}").unwrap();
    writeln!(output).unwrap();

    // MID$(s$, start, len) - 1-based index
    writeln!(
        output,
        "qb_string* qb_mid(qb_string* s, int32_t start, int32_t n) {{"
    )
    .unwrap();
    writeln!(
        output,
        "    if (start < 1 || n <= 0 || (size_t)start > s->len) return qb_string_new(\"\");"
    )
    .unwrap();
    writeln!(output, "    size_t idx = (size_t)(start - 1);").unwrap();
    writeln!(
        output,
        "    size_t len = (idx + (size_t)n > s->len) ? s->len - idx : (size_t)n;"
    )
    .unwrap();
    writeln!(output, "    qb_string* result = malloc(sizeof(qb_string));").unwrap();
    writeln!(output, "    result->len = len;").unwrap();
    writeln!(output, "    result->capacity = len + 1;").unwrap();
    writeln!(output, "    result->data = malloc(result->capacity);").unwrap();
    writeln!(output, "    memcpy(result->data, s->data + idx, len);").unwrap();
    writeln!(output, "    result->data[len] = '\\0';").unwrap();
    writeln!(output, "    return result;").unwrap();
    writeln!(output, "}}").unwrap();
    writeln!(output).unwrap();

    // INSTR(start, s$, find$) - 1-based, returns 0 if not found
    writeln!(
        output,
        "int32_t qb_instr(int32_t start, qb_string* s, qb_string* find) {{"
    )
    .unwrap();
    writeln!(
        output,
        "    if (start < 1 || (size_t)start > s->len || find->len == 0) return 0;"
    )
    .unwrap();
    writeln!(
        output,
        "    char* pos = strstr(s->data + start - 1, find->data);"
    )
    .unwrap();
    writeln!(output, "    return pos ? (int32_t)(pos - s->data + 1) : 0;").unwrap();
    writeln!(output, "}}").unwrap();
    writeln!(output).unwrap();

    // STR$(n) - convert number to string
    writeln!(output, "qb_string* qb_str(double n) {{").unwrap();
    writeln!(output, "    char buf[64];").unwrap();
    writeln!(output, "    snprintf(buf, sizeof(buf), \" %g\", n);").unwrap();
    writeln!(output, "    return qb_string_new(buf);").unwrap();
    writeln!(output, "}}").unwrap();
    writeln!(output).unwrap();

    // VAL(s$) - convert string to number
    writeln!(output, "double qb_val(qb_string* s) {{").unwrap();
    writeln!(output, "    return atof(s->data);").unwrap();
    writeln!(output, "}}").unwrap();
    writeln!(output).unwrap();

    // UCASE$(s$)
    writeln!(output, "qb_string* qb_ucase(qb_string* s) {{").unwrap();
    writeln!(output, "    qb_string* result = malloc(sizeof(qb_string));").unwrap();
    writeln!(output, "    result->len = s->len;").unwrap();
    writeln!(output, "    result->capacity = s->len + 1;").unwrap();
    writeln!(output, "    result->data = malloc(result->capacity);").unwrap();
    writeln!(
        output,
        "    for (size_t i = 0; i < s->len; i++) result->data[i] = toupper(s->data[i]);"
    )
    .unwrap();
    writeln!(output, "    result->data[s->len] = '\\0';").unwrap();
    writeln!(output, "    return result;").unwrap();
    writeln!(output, "}}").unwrap();
    writeln!(output).unwrap();

    // LCASE$(s$)
    writeln!(output, "qb_string* qb_lcase(qb_string* s) {{").unwrap();
    writeln!(output, "    qb_string* result = malloc(sizeof(qb_string));").unwrap();
    writeln!(output, "    result->len = s->len;").unwrap();
    writeln!(output, "    result->capacity = s->len + 1;").unwrap();
    writeln!(output, "    result->data = malloc(result->capacity);").unwrap();
    writeln!(
        output,
        "    for (size_t i = 0; i < s->len; i++) result->data[i] = tolower(s->data[i]);"
    )
    .unwrap();
    writeln!(output, "    result->data[s->len] = '\\0';").unwrap();
    writeln!(output, "    return result;").unwrap();
    writeln!(output, "}}").unwrap();
    writeln!(output).unwrap();

    // LTRIM$(s$)
    writeln!(output, "qb_string* qb_ltrim(qb_string* s) {{").unwrap();
    writeln!(output, "    size_t start = 0;").unwrap();
    writeln!(
        output,
        "    while (start < s->len && s->data[start] == ' ') start++;"
    )
    .unwrap();
    writeln!(output, "    return qb_right(s, (int32_t)(s->len - start));").unwrap();
    writeln!(output, "}}").unwrap();
    writeln!(output).unwrap();

    // RTRIM$(s$)
    writeln!(output, "qb_string* qb_rtrim(qb_string* s) {{").unwrap();
    writeln!(output, "    size_t end = s->len;").unwrap();
    writeln!(
        output,
        "    while (end > 0 && s->data[end - 1] == ' ') end--;"
    )
    .unwrap();
    writeln!(output, "    return qb_left(s, (int32_t)end);").unwrap();
    writeln!(output, "}}").unwrap();
    writeln!(output).unwrap();

    // SPACE$(n)
    writeln!(output, "qb_string* qb_space(int32_t n) {{").unwrap();
    writeln!(output, "    if (n <= 0) return qb_string_new(\"\");").unwrap();
    writeln!(output, "    qb_string* result = malloc(sizeof(qb_string));").unwrap();
    writeln!(output, "    result->len = (size_t)n;").unwrap();
    writeln!(output, "    result->capacity = result->len + 1;").unwrap();
    writeln!(output, "    result->data = malloc(result->capacity);").unwrap();
    writeln!(output, "    memset(result->data, ' ', result->len);").unwrap();
    writeln!(output, "    result->data[result->len] = '\\0';").unwrap();
    writeln!(output, "    return result;").unwrap();
    writeln!(output, "}}").unwrap();
    writeln!(output).unwrap();

    // STRING$(n, char$)
    writeln!(
        output,
        "qb_string* qb_string_fill(int32_t n, qb_string* c) {{"
    )
    .unwrap();
    writeln!(
        output,
        "    if (n <= 0 || c->len == 0) return qb_string_new(\"\");"
    )
    .unwrap();
    writeln!(output, "    qb_string* result = malloc(sizeof(qb_string));").unwrap();
    writeln!(output, "    result->len = (size_t)n;").unwrap();
    writeln!(output, "    result->capacity = result->len + 1;").unwrap();
    writeln!(output, "    result->data = malloc(result->capacity);").unwrap();
    writeln!(output, "    memset(result->data, c->data[0], result->len);").unwrap();
    writeln!(output, "    result->data[result->len] = '\\0';").unwrap();
    writeln!(output, "    return result;").unwrap();
    writeln!(output, "}}").unwrap();
    writeln!(output).unwrap();
}

/// Emits utility functions used by DATA/READ and other constructs.
fn emit_utility_functions(output: &mut String) {
    // qb_str_from_c - create qb_string from C string (alias for qb_string_new)
    writeln!(output, "qb_string* qb_str_from_c(const char* s) {{").unwrap();
    writeln!(output, "    return qb_string_new(s);").unwrap();
    writeln!(output, "}}").unwrap();
    writeln!(output).unwrap();

    // qb_str_float - convert float to string (used by DATA/READ)
    writeln!(output, "qb_string* qb_str_float(double n) {{").unwrap();
    writeln!(output, "    char buf[64];").unwrap();
    writeln!(output, "    snprintf(buf, sizeof(buf), \"%g\", n);").unwrap();
    writeln!(output, "    return qb_string_new(buf);").unwrap();
    writeln!(output, "}}").unwrap();
    writeln!(output).unwrap();
}
